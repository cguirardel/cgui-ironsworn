/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => PasteTransform
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var SCRIPT_TIMEOUT_MS = 3e3;
var NOTICE_DURATION_SHORT = 3e3;
var NOTICE_DURATION_NORMAL = 5e3;
var NOTICE_DURATION_LONG = 1e4;
var DEFAULT_SETTINGS = {
  rules: [
    {
      pattern: "^https://github.com/[^/]+/([^/]+)$",
      type: "replace",
      replacer: "[\u{1F408}\u200D\u2B1B $1]($&)",
      script: "",
      enabled: true
    },
    {
      pattern: "^https://\\w+.wikipedia.org/wiki/([^\\s]+)$",
      type: "replace",
      replacer: "[\u{1F4D6} $1]($&)",
      script: "",
      enabled: true
    },
    {
      pattern: "^https://github.com/([^/]+)/([^/]+)/issues/(\\d+)$",
      type: "script",
      replacer: "",
      script: "const url=`https://api.github.com/repos/${ctx.match[1]}/${ctx.match[2]}/issues/${ctx.match[3]}`\nconst response = await fetch(url);\nconst data = await response.json();\nconst title = data.title;\nreturn `[${ctx.match[2]}#${ctx.match[3]}: ${title}](${ctx.foundText})`;",
      enabled: false
    },
    {
      pattern: "^https://github.com/([^/]+)/([^/]+)/pull/(\\d+)$",
      type: "script",
      replacer: "",
      script: "const url=`https://api.github.com/repos/${ctx.match[1]}/${ctx.match[2]}/pulls/${ctx.match[3]}`\nconst response = await fetch(url);\nconst data = await response.json();\nconst title = data.title;\nreturn `[${ctx.match[2]}#${ctx.match[3]}: ${title}](${ctx.foundText})`;",
      enabled: false
    }
  ],
  settingsFormatVersion: 2,
  debugMode: false,
  showRuleNotifications: true,
  scriptSecurityWarningAccepted: false
};
var ScriptContext = class {
  // Debug mode flag for user scripts
  constructor(match, debug) {
    this.match = match;
    this.debug = debug;
  }
  // Getter for convenient access to the matched substring
  get foundText() {
    return this.match[0];
  }
};
var ReplaceRule = class {
  constructor(pattern, replacer, script = null, ruleNumber) {
    this.pattern = new RegExp(pattern, "g");
    this.replacer = replacer;
    this.script = script;
    this.ruleNumber = ruleNumber;
  }
  async executeScript(match, debugMode, app, ruleNumber) {
    if (this.script) {
      let timeoutId = null;
      try {
        const startTime = Date.now();
        const AsyncFunction = Object.getPrototypeOf(async function() {
        }).constructor;
        const fn = new AsyncFunction("ctx", this.script);
        const context = new ScriptContext(match, debugMode);
        let timeoutShown = false;
        timeoutId = setTimeout(() => {
          if (!timeoutShown) {
            timeoutShown = true;
            new import_obsidian.Notice(`Rule #${ruleNumber} is taking longer than expected`, NOTICE_DURATION_NORMAL);
          }
        }, SCRIPT_TIMEOUT_MS);
        const scriptPromise = fn(context);
        const result2 = await scriptPromise;
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        const endTime = Date.now();
        if (debugMode) {
          console.log(`Matched regex: ${this.pattern}`);
          console.log(`Match object:`, match);
          console.log(`Script execution time: ${endTime - startTime}ms`);
          console.log(`Result: '${result2}'`);
        }
        return result2;
      } catch (error) {
        if (timeoutId !== null) {
          clearTimeout(timeoutId);
          timeoutId = null;
        }
        console.error(`Error executing script for rule #${ruleNumber}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        new import_obsidian.Notice(`Rule #${ruleNumber} script execution error: ${errorMessage}`, NOTICE_DURATION_NORMAL);
        return match[0];
      }
    }
    const result = match[0].replace(this.pattern, this.replacer);
    if (debugMode) {
      console.log(`Matched regex: ${this.pattern}`);
      console.log(`Result: '${result}'`);
    }
    return result;
  }
  // Process all matches in the source text with a script
  async executeScriptForAllMatches(source, debugMode, app, ruleNumber) {
    if (!this.script) {
      return source;
    }
    const matches = Array.from(source.matchAll(this.pattern));
    if (matches.length === 0) {
      return source;
    }
    let result = source;
    for (let i = matches.length - 1; i >= 0; i--) {
      const match = matches[i];
      const matchStart = match.index;
      const matchEnd = matchStart + match[0].length;
      const replacement = await this.executeScript(match, debugMode, app, ruleNumber);
      result = result.substring(0, matchStart) + replacement + result.substring(matchEnd);
    }
    return result;
  }
};
var PasteTransform = class extends import_obsidian.Plugin {
  async onload() {
    await this.loadSettings();
    this.addSettingTab(new PasteTransformSettingsTab(this.app, this));
    this.registerEvent(this.app.workspace.on("editor-paste", (event) => this.onPaste(event)));
  }
  async onPaste(event) {
    var _a, _b, _c, _d;
    if (event.defaultPrevented) {
      if (this.settings.debugMode) {
        console.log("It doesn't try to apply rules because event prevented already.");
      }
      return;
    }
    let types = (_a = event.clipboardData) == null ? void 0 : _a.types;
    if (this.settings.debugMode) {
      console.log("transform plugin, clipboard content types:", types);
    }
    if (types === void 0 || types.length != 1 || types[0] != "text/plain") {
      return;
    }
    let plainText = (_b = event.clipboardData) == null ? void 0 : _b.getData("text/plain");
    if (plainText === void 0 || plainText == "") {
      return;
    }
    if (this.settings.debugMode) {
      console.log(`Original text: '${plainText}'`);
    }
    const hasMatchingRule = this.rules.some((rule) => {
      rule.pattern.lastIndex = 0;
      const matches = rule.pattern.test(plainText);
      rule.pattern.lastIndex = 0;
      return matches;
    });
    let preventedDefault = false;
    if (hasMatchingRule) {
      event.preventDefault();
      preventedDefault = true;
    }
    const { changed, result } = await this.applyRules(plainText);
    if (preventedDefault) {
      const textToInsert = changed ? result : plainText;
      if (this.settings.debugMode) {
        console.log(`Final text: '${textToInsert}'`);
      }
      (_d = (_c = this.app.workspace.activeEditor) == null ? void 0 : _c.editor) == null ? void 0 : _d.replaceSelection(textToInsert);
      if (this.settings.debugMode) {
        console.log(`Replaced selection with: '${textToInsert}'`);
      }
    }
  }
  onunload() {
  }
  async loadSettings() {
    const loadedData = await this.loadData();
    if (loadedData && loadedData.settingsFormatVersion === 1 && loadedData.patterns !== void 0) {
      const oldSettings = loadedData;
      const newRules = [];
      const minIndex = Math.min(oldSettings.patterns.length, oldSettings.replacers.length);
      for (let i = 0; i < minIndex; i++) {
        newRules.push({
          pattern: oldSettings.patterns[i],
          type: "replace",
          replacer: oldSettings.replacers[i],
          script: "",
          enabled: true
        });
      }
      this.settings = {
        rules: newRules,
        settingsFormatVersion: 2,
        // Update to new format version
        debugMode: oldSettings.debugMode || false,
        showRuleNotifications: true,
        scriptSecurityWarningAccepted: false
      };
    } else {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, loadedData);
      if (this.settings.scriptSecurityWarningAccepted === void 0) {
        this.settings.scriptSecurityWarningAccepted = false;
      }
    }
    const hasEnabledScriptRules = this.settings.rules.some(
      (rule) => rule.type === "script" && rule.enabled
    );
    if (!hasEnabledScriptRules && this.settings.scriptSecurityWarningAccepted) {
      this.settings.scriptSecurityWarningAccepted = false;
      await this.saveSettings();
    }
    this.compileRules();
  }
  compileRules() {
    this.rules = [];
    for (let i = 0; i < this.settings.rules.length; i++) {
      const rule = this.settings.rules[i];
      const ruleNumber = i + 1;
      if (rule.enabled) {
        if (rule.type === "script" && !this.settings.scriptSecurityWarningAccepted) {
          continue;
        }
        try {
          this.rules.push(
            new ReplaceRule(rule.pattern, rule.replacer, rule.type === "script" ? rule.script : null, ruleNumber)
          );
        } catch (error) {
          console.error(`Error compiling rule #${ruleNumber}:`, error);
          const errorMessage = error instanceof Error ? error.message : String(error);
          new import_obsidian.Notice(`Rule #${ruleNumber} has invalid pattern: ${errorMessage}`, NOTICE_DURATION_NORMAL);
        }
      }
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Execute a specific rule on all matches in the source
  async executeRule(rule, source, ruleNumber) {
    rule.pattern.lastIndex = 0;
    const hasMatch = rule.pattern.test(source);
    rule.pattern.lastIndex = 0;
    if (!hasMatch) {
      return source;
    }
    if (this.settings.debugMode) {
      console.log(`Rule #${ruleNumber} triggered`);
    }
    if (rule.script) {
      if (!this.settings.scriptSecurityWarningAccepted) {
        console.error("BUG: Script rule executed without security acceptance. Please report this to the plugin developers.");
        new import_obsidian.Notice("\u26A0\uFE0F Security error detected. Script execution blocked. Please report this bug to the plugin developers.", NOTICE_DURATION_LONG);
        return source;
      }
      return await rule.executeScriptForAllMatches(source, this.settings.debugMode, this.app, ruleNumber);
    } else {
      const result = source.replace(rule.pattern, rule.replacer);
      if (this.settings.debugMode) {
        console.log(`Rule #${ruleNumber} - Matched regex: ${rule.pattern}`);
        console.log(`Rule #${ruleNumber} - Result: '${result}'`);
      }
      return result;
    }
  }
  async applyRules(source) {
    if (source === void 0 || source === null) {
      return { changed: false, result: "" };
    }
    let result = source;
    let changed = false;
    const triggeredRuleNumbers = [];
    for (const rule of this.rules) {
      try {
        const beforeRule = result;
        result = await this.executeRule(rule, result, rule.ruleNumber);
        if (result !== beforeRule) {
          changed = true;
          triggeredRuleNumbers.push(rule.ruleNumber);
        }
      } catch (error) {
        console.error(`Error applying rule #${rule.ruleNumber}:`, error);
        const errorMessage = error instanceof Error ? error.message : String(error);
        new import_obsidian.Notice(`Rule #${rule.ruleNumber} execution error: ${errorMessage}`, NOTICE_DURATION_NORMAL);
      }
    }
    if (changed && this.settings.showRuleNotifications && triggeredRuleNumbers.length > 0) {
      const rulesList = triggeredRuleNumbers.join(", ");
      const message = triggeredRuleNumbers.length === 1 ? `Rule #${rulesList} triggered` : `Rules #${rulesList} triggered`;
      new import_obsidian.Notice(message, NOTICE_DURATION_SHORT);
    }
    if (this.settings.debugMode && triggeredRuleNumbers.length > 0) {
      console.log(`Triggered rules: #${triggeredRuleNumbers.join(", #")}`);
    }
    return { changed, result };
  }
};
var PasteTransformSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  // Show security warning and ask user to accept risks
  async showSecurityWarningAndAccept() {
    const confirmed = confirm(
      "\u{1F6A8}\u{1F6A8}\u{1F6A8} SECURITY WARNING \u{1F6A8}\u{1F6A8}\u{1F6A8}\n\n\u26A0\uFE0F  DANGER! Script rules execute JavaScript code with FULL access to your system!\n\n\u274C Malicious scripts can:\n   \u2022 Access ALL your files and notes\n   \u2022 Send data to external servers\n   \u2022 Execute ANY code on your computer\n   \u2022 Steal passwords and sensitive information\n   \u2022 Delete or modify your data\n\n\u270B ONLY enable script rules from sources you COMPLETELY trust!\n\n\u2753 Do you understand and accept these risks?\n\nClick OK ONLY if you:\n  \u2713 Wrote the script yourself, OR\n  \u2713 Fully reviewed and understand the code, OR\n  \u2713 Trust the source completely"
    );
    if (confirmed) {
      this.plugin.settings.scriptSecurityWarningAccepted = true;
      await this.plugin.saveSettings();
      this.plugin.compileRules();
      return true;
    }
    return false;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.renderSecurityToggle(containerEl);
    this.renderDebugToggle(containerEl);
    this.renderNotificationsToggle(containerEl);
    this.renderTestSection(containerEl);
    this.renderRulesSection(containerEl);
  }
  renderSecurityToggle(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Script rules enabled").setDesc("Enable or disable execution of JavaScript code in script rules. This affects security.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.scriptSecurityWarningAccepted);
      toggle.onChange(async (value) => {
        if (value) {
          const accepted = await this.showSecurityWarningAndAccept();
          if (!accepted) {
            this.display();
            return;
          }
          this.plugin.compileRules();
          this.display();
        } else {
          const confirmed = confirm(
            "Are you sure you want to disable script rules?\n\nAll script rules will stop working until you enable this setting again."
          );
          if (confirmed) {
            this.plugin.settings.scriptSecurityWarningAccepted = false;
            for (let rule of this.plugin.settings.rules) {
              if (rule.type === "script" && rule.enabled) {
                rule.enabled = false;
              }
            }
            await this.plugin.saveSettings();
            this.plugin.compileRules();
            this.display();
          } else {
            this.display();
          }
        }
      });
    });
  }
  renderDebugToggle(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Debug Mode").setDesc("Enable to see detailed logs in the developer console").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.debugMode);
      toggle.onChange(async (value) => {
        this.plugin.settings.debugMode = value;
        await this.plugin.saveSettings();
      });
    });
  }
  renderNotificationsToggle(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Show Rule Notifications").setDesc("Show notifications when rules are triggered").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.showRuleNotifications);
      toggle.onChange(async (value) => {
        this.plugin.settings.showRuleNotifications = value;
        await this.plugin.saveSettings();
      });
    });
  }
  renderTestSection(containerEl) {
    const testContainer = containerEl.createDiv({ cls: "paste-code-transform" });
    let trySource = null;
    let tryDest = null;
    const handleChanges = async () => {
      try {
        const { result } = await this.plugin.applyRules((trySource == null ? void 0 : trySource.getValue()) || "");
        tryDest == null ? void 0 : tryDest.setValue(result);
      } catch (e) {
        tryDest == null ? void 0 : tryDest.setValue("ERROR:\n" + e);
      }
    };
    const sourceSetting = new import_obsidian.Setting(testContainer).setName("Test Rules").setDesc("Test your rules with sample text").addTextArea((ta) => {
      trySource = ta;
      ta.setPlaceholder("Enter sample text to test your rules");
      ta.inputEl.classList.add("test-textarea");
      ta.onChange(async () => {
        await handleChanges();
      });
    });
    sourceSetting.settingEl.classList.add("test-rules-setting");
    const resultSetting = new import_obsidian.Setting(testContainer).setName("Test Result").setDesc("The result after applying rules to the sample text").addTextArea((ta) => {
      tryDest = ta;
      ta.setPlaceholder("Transformed result will appear here");
      ta.inputEl.classList.add("test-textarea");
      ta.setDisabled(true);
    });
    resultSetting.settingEl.classList.add("test-rules-setting");
  }
  renderRulesSection(containerEl) {
    const topLevelContainer = containerEl.createDiv({ cls: "paste-code-transform" });
    const rulesContainer = topLevelContainer.createDiv({ cls: "rules-container" });
    const renderRule = (rule, index) => {
      const ruleContainer = rulesContainer.createDiv({ cls: "rule-container" });
      const isScriptRuleLocked = rule.type === "script" && !this.plugin.settings.scriptSecurityWarningAccepted;
      const headerRow = ruleContainer.createDiv({ cls: "rule-header" });
      const ruleNumber = index + 1;
      const ruleNumberEl = headerRow.createEl("span", { text: `Rule #${ruleNumber}`, cls: "rule-number" });
      const typeDropdownContainer = headerRow.createDiv({ cls: "type-dropdown-container" });
      const typeDropdown = new import_obsidian.DropdownComponent(typeDropdownContainer);
      typeDropdown.addOption("replace", "Regex Replacer");
      typeDropdown.addOption("script", "Script Replacer");
      typeDropdown.setValue(rule.type);
      typeDropdown.onChange(async (value) => {
        if (value === "script" && !this.plugin.settings.scriptSecurityWarningAccepted) {
          const accepted = await this.showSecurityWarningAndAccept();
          if (!accepted) {
            typeDropdown.setValue(rule.type);
            return;
          }
        }
        this.plugin.settings.rules[index].type = value;
        await this.plugin.saveSettings();
        this.plugin.compileRules();
        this.display();
      });
      if (isScriptRuleLocked) {
        typeDropdown.setDisabled(true);
      }
      const deleteButtonContainer = headerRow.createDiv({ cls: "delete-button-container" });
      const deleteButton = new import_obsidian.ButtonComponent(deleteButtonContainer);
      deleteButton.setIcon("trash");
      deleteButton.setTooltip("Delete rule");
      deleteButton.onClick(async () => {
        const confirmed = confirm(
          `\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u043F\u0440\u0430\u0432\u0438\u043B\u043E #${ruleNumber}?

Regex: ${rule.pattern}`
        );
        if (confirmed) {
          this.plugin.settings.rules.splice(index, 1);
          await this.plugin.saveSettings();
          this.plugin.compileRules();
          this.display();
        }
      });
      const enabledToggle = new import_obsidian.Setting(ruleContainer);
      enabledToggle.setName("Rule enabled");
      enabledToggle.settingEl.classList.add("setting-no-border");
      if (isScriptRuleLocked) {
        const lockWarning = enabledToggle.descEl.createDiv({ cls: "script-rule-locked-warning" });
        lockWarning.createEl("span", { text: "\u2139\uFE0F This is a script rule. " });
        lockWarning.createEl("span", { text: "Try to enable it to learn about security considerations. You can also delete it if not needed." });
      }
      enabledToggle.addToggle((toggle) => {
        toggle.setValue(rule.enabled);
        toggle.onChange(async (value) => {
          if (value && rule.type === "script" && !this.plugin.settings.scriptSecurityWarningAccepted) {
            const accepted = await this.showSecurityWarningAndAccept();
            if (!accepted) {
              toggle.setValue(false);
              return;
            }
            this.plugin.settings.rules[index].enabled = value;
            await this.plugin.saveSettings();
            this.plugin.compileRules();
            this.display();
            return;
          }
          this.plugin.settings.rules[index].enabled = value;
          await this.plugin.saveSettings();
          this.plugin.compileRules();
        });
      });
      const patternContainer = ruleContainer.createDiv({ cls: "pattern-container" });
      patternContainer.createEl("label", { text: "Match regex" });
      const patternInput = new import_obsidian.TextComponent(patternContainer);
      patternInput.setValue(rule.pattern);
      patternInput.setPlaceholder("Enter regex pattern");
      patternInput.inputEl.classList.add("text-input-full");
      patternInput.onChange(async (value) => {
        this.plugin.settings.rules[index].pattern = value;
        await this.plugin.saveSettings();
        this.plugin.compileRules();
      });
      if (isScriptRuleLocked) {
        patternInput.setDisabled(true);
      }
      if (rule.type === "replace") {
        const replacerContainer = ruleContainer.createDiv({ cls: "replacer-container" });
        replacerContainer.createEl("label", { text: "Replacer" });
        const replacerInput = new import_obsidian.TextComponent(replacerContainer);
        replacerInput.setValue(rule.replacer);
        replacerInput.setPlaceholder("Enter replacement string");
        replacerInput.inputEl.classList.add("text-input-full");
        replacerInput.onChange(async (value) => {
          this.plugin.settings.rules[index].replacer = value;
          await this.plugin.saveSettings();
          this.plugin.compileRules();
        });
      }
      if (rule.type === "script") {
        const scriptContainer = ruleContainer.createDiv({ cls: "script-container" });
        scriptContainer.createEl("label", { text: "Script" });
        const scriptInput = new import_obsidian.TextAreaComponent(scriptContainer);
        scriptInput.setValue(rule.script);
        scriptInput.setPlaceholder("// Enter JavaScript code here\n// You can use async/await directly\nconst response = await fetch('https://httpbin.org/get');\nconst data = await response.json();\nreturn data.url;");
        scriptInput.inputEl.classList.add("script-textarea");
        scriptInput.onChange(async (value) => {
          this.plugin.settings.rules[index].script = value;
          await this.plugin.saveSettings();
          this.plugin.compileRules();
        });
        if (isScriptRuleLocked) {
          scriptInput.setDisabled(true);
        }
      }
    };
    this.plugin.settings.rules.forEach((rule, index) => {
      renderRule(rule, index);
    });
    const addButtonContainer = rulesContainer.createDiv({ cls: "add-button-container" });
    const addButton = new import_obsidian.ButtonComponent(addButtonContainer);
    addButton.setButtonText("Add new rule");
    addButton.setCta();
    addButton.onClick(async () => {
      this.plugin.settings.rules.push({
        pattern: "",
        type: "replace",
        replacer: "",
        script: "",
        enabled: true
      });
      await this.plugin.saveSettings();
      this.plugin.compileRules();
      this.display();
    });
  }
};

/* nosourcemap */